Terminals unused in grammar

    INTEGER_LITERAL
    REAL_LITERAL
    COMPLEX_LITERAL
    CHAR_LITERAL
    STRING_LITERAL
    IDENTIFIER
    "["
    "]"
    "("
    ")"
    "{"
    "}"
    ";"
    ":"
    "=>"
    "+"
    "-"
    "*"
    "/"
    "//"
    "^"
    "%"
    "+="
    "-="
    "*="
    "/="
    "//="
    "^="
    "%="
    "+<"
    "-<"
    "*<"
    "/<"
    "//<"
    "^<"
    "%<"
    "+<="
    "-<="
    "*<="
    "/<="
    "//<="
    "^<="
    "%<="
    "&&"
    "||"
    "!"
    "<"
    "<="
    "<=>"
    ">="
    ">"
    "=="
    "!="
    "|"
    "^^"
    "~"
    "<<"
    ">>"
    "&="
    "|="
    "^^="
    "~="
    "<<="
    ">>="
    "&<"
    "|<"
    "^^<"
    "~<"
    "<<<"
    ">><"
    "&<="
    "|<="
    "^^<="
    "~<="
    "<<<="
    ">><="
    "="
    "<-"
    "++"
    "--"
    "..."
    "::"
    "."
    "?"
    "int8_t"
    "int16_t"
    "int32_t"
    "int64_t"
    "int"
    "real32_t"
    "real64_t"
    "real"
    "bool"
    "char"
    "mod"
    "void"
    "true"
    "false"
    "this"
    "nptr"
    "let"
    "const"
    "compeval"
    "pure"
    "static"
    "nothrow"
    "in"
    "inout"
    "out"
    "move"
    "operator"
    "delete"
    "class"
    "public"
    "protected"
    "private"
    "enum"
    "constructor"
    "destructor"
    "default"
    "define"
    "if"
    "else"
    "else if"
    "for"
    "do"
    "while"
    "try"
    "catch"
    "throw"
    "break"
    "return"
    "continue"
    "match"
    "when"
    "typeset"
    "template"
    "where"
    "module"
    "namespace"
    "import"
    "from"
    "as"
    "with"
    "is"
    "sizeof"
    "typeof"
    "static_assert"
    "assert"
    "new"
    "dynamic"


Grammar

    0 $accept: nikola $end

    1 nikola: "&"


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    INTEGER_LITERAL <std::string> (258)
    REAL_LITERAL <std::string> (259)
    COMPLEX_LITERAL <std::string> (260)
    CHAR_LITERAL <std::string> (261)
    STRING_LITERAL <std::string> (262)
    IDENTIFIER <std::string> (263)
    "[" (264)
    "]" (265)
    "(" (266)
    ")" (267)
    "{" (268)
    "}" (269)
    ";" (270)
    ":" (271)
    "=>" (272)
    "+" (273)
    "-" (274)
    "*" (275)
    "/" (276)
    "//" (277)
    "^" (278)
    "%" (279)
    "+=" (280)
    "-=" (281)
    "*=" (282)
    "/=" (283)
    "//=" (284)
    "^=" (285)
    "%=" (286)
    "+<" (287)
    "-<" (288)
    "*<" (289)
    "/<" (290)
    "//<" (291)
    "^<" (292)
    "%<" (293)
    "+<=" (294)
    "-<=" (295)
    "*<=" (296)
    "/<=" (297)
    "//<=" (298)
    "^<=" (299)
    "%<=" (300)
    "&&" (301)
    "||" (302)
    "!" (303)
    "<" (304)
    "<=" (305)
    "<=>" (306)
    ">=" (307)
    ">" (308)
    "==" (309)
    "!=" (310)
    "&" (311) 1
    "|" (312)
    "^^" (313)
    "~" (314)
    "<<" (315)
    ">>" (316)
    "&=" (317)
    "|=" (318)
    "^^=" (319)
    "~=" (320)
    "<<=" (321)
    ">>=" (322)
    "&<" (323)
    "|<" (324)
    "^^<" (325)
    "~<" (326)
    "<<<" (327)
    ">><" (328)
    "&<=" (329)
    "|<=" (330)
    "^^<=" (331)
    "~<=" (332)
    "<<<=" (333)
    ">><=" (334)
    "=" (335)
    "<-" (336)
    "++" (337)
    "--" (338)
    "..." (339)
    "::" (340)
    "." (341)
    "?" (342)
    "int8_t" (343)
    "int16_t" (344)
    "int32_t" (345)
    "int64_t" (346)
    "int" (347)
    "real32_t" (348)
    "real64_t" (349)
    "real" (350)
    "bool" (351)
    "char" (352)
    "mod" (353)
    "void" (354)
    "true" (355)
    "false" (356)
    "this" (357)
    "nptr" (358)
    "let" (359)
    "const" (360)
    "compeval" (361)
    "pure" (362)
    "static" (363)
    "nothrow" (364)
    "in" (365)
    "inout" (366)
    "out" (367)
    "move" (368)
    "operator" (369)
    "delete" (370)
    "class" (371)
    "public" (372)
    "protected" (373)
    "private" (374)
    "enum" (375)
    "constructor" (376)
    "destructor" (377)
    "default" (378)
    "define" (379)
    "if" (380)
    "else" (381)
    "else if" (382)
    "for" (383)
    "do" (384)
    "while" (385)
    "try" (386)
    "catch" (387)
    "throw" (388)
    "break" (389)
    "return" (390)
    "continue" (391)
    "match" (392)
    "when" (393)
    "typeset" (394)
    "template" (395)
    "where" (396)
    "module" (397)
    "namespace" (398)
    "import" (399)
    "from" (400)
    "as" (401)
    "with" (402)
    "is" (403)
    "sizeof" (404)
    "typeof" (405)
    "static_assert" (406)
    "assert" (407)
    "new" (408)
    "dynamic" (409)


Nonterminals, with rules where they appear

    $accept (155)
        on left: 0
    nikola (156)
        on left: 1
        on right: 0


State 0

    0 $accept: • nikola $end

    "&"  shift, and go to state 1

    nikola  go to state 2


State 1

    1 nikola: "&" •

    $default  reduce using rule 1 (nikola)


State 2

    0 $accept: nikola • $end

    $end  shift, and go to state 3


State 3

    0 $accept: nikola $end •

    $default  accept
