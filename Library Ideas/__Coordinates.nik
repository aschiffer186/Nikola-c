module Nik.Math.Coordinates;

namespace Nik
{
    export let class CartesianPoint2D : template<T : Arithmetic> = {
        let public x : T;
        let public y : T;

        let public compeval nothrow constructor(__x : T, __y : T) = {
            x = __x;
            y = __y;
        }

        let public compeval nothrow constructor(other : CartesianPoint2D<U>) 
            : template<U : Arithmetic> where Constructible<T, U> = {
            x = new T{other.x};
            y = new T{other.y};
        }

        let public compeval nothrow operator=(other: CartesianPoint2D<U>)
            : template<U : Arithmetic> where Constructible<T, U> = {
            x = new T{other.x};
            y = new T{other.y};
        }

        let compeval pure quadrant() -> int8_t = {
            if (x > 0 && y > 0)
            {
                return 1;
            }
            else if (x < 0 && y > 0)
            {
                return 2;
            }
            else if (x < 0 && y < 0)
            {
                return 3;
            }
            else 
            {
                return 4;
            }
        }
    }

    let compeval pure rotate(point : CartesianPoint2D, theta) -> CartesianPoint2D = {
        let __xPrime = point.x*cos(theta) - point.y*sin(theta);
        let __yPRime =
    }

    export let class CartesianPoint3D : template<T : Arithmetic> = {
        let public x : T;
        let public y : T;
        ler public z : T;

        let public compeval nothrow constructor(__x : T, __y : T, __z : T) = {
            x = __x;
            y = __y;
            z = __z;
        }

        let public compeval nothrow constructor(other : CartesianPoint3D<U>) 
            : template<U : Arithmetic> where Constructible<T, U> = {
            x = new T{other.x};
            y = new T{other.y};
            z = new T{other.z};
        }

        let public compeval nothrow operator=(other: CartesianPoint3D<U>)
            : template<U : Arithmetic> where Constructible<T, U> = {
            x = new T{other.x};
            y = new T{other.y};
            z = new T{other.z};
        }
    }

    let compeval pure distance(p1, p2) -> real = {
       
    }
}